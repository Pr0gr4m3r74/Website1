<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Karten-Mini-Game</title>
<link rel="stylesheet" href="kartenspiel.css">
</head>
<body>
<header>
  <h1>Karten-Mini-Game</h1>
  <nav>
    <a href="index.html">Start</a>
    <a href="minigames.html" aria-current="page">Mini-Games</a>
    <a href="projects.html">Projekte</a>
    <a href="kontakt.html">Kontakt</a>
    <a href="impressum.html">Impressum</a>
  </nav>
</header>

<div class="main-container">
  <div id="altar">
    <h3>Altar</h3>
    <div id="altar-slots">
      <div class="altar-slot" data-index="0"></div>
      <div class="altar-slot" data-index="1"></div>
      <div class="altar-slot" data-index="2"></div>
    </div>
    <button id="sacrificeBtn">Opfern & Belohnung</button>
    <div id="altar-result"></div>
  </div>

  <div class="game-area">
    <div class="game-controls">
      <button id="drawBtn">Karte ziehen</button>
      <div id="currentCard"></div>
    </div>

    <h2>Inventar</h2>
    <div id="inventory" class="inventory" aria-live="polite"></div>
  </div>
</div>

<footer>Â© 2026 IT Solutions</footer>

<script>
/* Daten & Mapping */
const rarities = [
  { name: 'GewÃ¶hnlich', chance: 70 },
  { name: 'Selten', chance: 20 },
  { name: 'Episch', chance: 8 },
  { name: 'LegendÃ¤r', chance: 1.99 },
  { name: 'Mythisch', chance: 0.01 }
];
const rarityMap = {
  'GewÃ¶hnlich': 'common',
  'Selten': 'rare',
  'Episch': 'epic',
  'LegendÃ¤r': 'legendary',
  'Mythisch': 'mythic'
};
const tiers = ['GewÃ¶hnlich','Selten','Episch','LegendÃ¤r','Mythisch'];

const allCards = [
  { name: 'Erd-Essenz', icon: 'â¬›', rarity: 'GewÃ¶hnlich' },
  { name: 'Holz-Essenz', icon: 'ğŸŸ«', rarity: 'GewÃ¶hnlich' },
  { name: 'Wasser-Essenz', icon: 'ğŸ’§', rarity: 'GewÃ¶hnlich' },
  { name: 'Wind-Essenz', icon: 'ğŸŒ«ï¸', rarity: 'GewÃ¶hnlich' },
  { name: 'Licht-Funke', icon: 'âœ¨', rarity: 'GewÃ¶hnlich' },
  { name: 'Schatten-Rest', icon: 'ğŸŒ‘', rarity: 'GewÃ¶hnlich' },
  { name: 'Asche-Partikel', icon: 'ğŸŸ¤', rarity: 'GewÃ¶hnlich' },
  { name: 'Kristall-Essenz', icon: 'ğŸ”·', rarity: 'Selten' },
  { name: 'Energie-Kern', icon: 'ğŸ”‹', rarity: 'Selten' },
  { name: 'Flammenkern', icon: 'ğŸ”¥', rarity: 'Selten' },
  { name: 'Frostkern', icon: 'â„ï¸', rarity: 'Selten' },
  { name: 'Gold-Matrix', icon: 'ğŸŸ¨', rarity: 'Episch' },
  { name: 'Astral-Kern', icon: 'ğŸŒŒ', rarity: 'Episch' },
  { name: 'Zeit-Fragment', icon: 'â³', rarity: 'Episch' },
  { name: 'Lichtkristall', icon: 'ğŸ’', rarity: 'Episch' },
  { name: 'Klinge der Ordnung', icon: 'ğŸ—¡ï¸', rarity: 'LegendÃ¤r' },
  { name: 'Bogen der Weite', icon: 'ğŸ¹', rarity: 'LegendÃ¤r' },
  { name: 'Siegel der Macht', icon: 'ğŸ”±', rarity: 'LegendÃ¤r' },
  { name: 'Krone der Herrschaft', icon: 'ğŸ‘‘', rarity: 'LegendÃ¤r' },
  { name: 'SingularitÃ¤t', icon: 'âš«', rarity: 'Mythisch' },
  { name: 'Paradox', icon: 'âšª', rarity: 'Mythisch' }
];

let inventory = [];
let altarSlots = [null, null, null];

/* Utility */
function rarityClass(r) { return rarityMap[r] || r.toLowerCase(); }
function weightedRandomRarity() {
  let roll = Math.random()*100, sum=0;
  for (let r of rarities){ sum+=r.chance; if (roll<=sum) return r.name; }
  return rarities[0].name;
}
function pickRandomCardByRarity(rarity){
  const arr = allCards.filter(c => c.rarity === rarity);
  return { ...arr[Math.floor(Math.random()*arr.length)] };
}
function moveInArray(arr, from, to){
  if (from === to) return;
  const item = arr.splice(from,1)[0];
  arr.splice(to,0,item);
}
function randomQuality(){
  const qRoll = Math.random()*100;
  if (qRoll <= 50) return 1 + Math.floor(Math.random()*2); // 1-2
  else if (qRoll <= 80) return 3;
  else if (qRoll <= 95) return 4;
  else return 5;
}

/* Draw */
function drawCard(){
  let rarity = weightedRandomRarity();
  let card = pickRandomCardByRarity(rarity);
  card.quality = randomQuality();
  inventory.push(card);
  showCurrentCard(card);
  renderInventory();
}

/* Anzeige der aktuellen Karte */
function showCurrentCard(card){
  const div = document.getElementById('currentCard');
  let stars = 'âœ¦'.repeat(card.quality);
  div.innerHTML = `<div class="card ${rarityClass(card.rarity)}">
    <div class="ornament">${card.icon}</div>
    <div class="rarity">${card.rarity}</div>
    <div class="name">${card.name}</div>
    <div class="icon" style="font-size:48px">${card.icon}</div>
    <div class="stars">${stars}</div>
  </div>`;
}

/* Inventar rendern */
function renderInventory(){
  const inv = document.getElementById('inventory');
  inv.innerHTML = '';
  inventory.forEach((c,i) => {
    const d = document.createElement('div');
    d.className = `small-card ${rarityClass(c.rarity)}`;
    d.draggable = true;
    d.dataset.index = i;
    let stars = 'âœ¦'.repeat(c.quality);
    d.innerHTML = `<div class="ornament">${c.icon}</div><div class="rarity">${c.rarity}</div><div class="name">${c.name}</div><div class="icon" style="font-size:36px">${c.icon}</div><div class="stars">${stars}</div>`;
    inv.appendChild(d);
  });
  attachDraggables();
  renderAltar();
}

/* Drag handlers fÃ¼r Inventarkarten (Start / Ende) */
function attachDraggables(){
  const cards = document.querySelectorAll('#inventory .small-card');
  cards.forEach(card => {
    card.addEventListener('dragstart', e => {
      // set data
      e.dataTransfer.setData('text/plain', 'inv:' + card.dataset.index);
      // hide default drag image to make drag less disruptive
      try { e.dataTransfer.setDragImage(new Image(), 0, 0); } catch(e){}
      card.classList.add('dragging');
      try { e.dataTransfer.effectAllowed = 'move'; } catch(e){}
    });
    card.addEventListener('dragend', e => { card.classList.remove('dragging'); });
    // drop on a card -> insert before this card
    card.addEventListener('dragover', e => {
      e.preventDefault();
      card.classList.add('insert-before');
    });
    card.addEventListener('dragleave', e => { card.classList.remove('insert-before'); });
    card.addEventListener('drop', e => {
      e.preventDefault();
      card.classList.remove('insert-before');
      const data = e.dataTransfer.getData('text/plain');
      const targetIdx = Number(card.dataset.index);
      if (!data) return;
      if (data.startsWith('inv:')){
        const srcIdx = Number(data.split(':')[1]);
        if (isNaN(srcIdx)) return;
        // adjust target when removing earlier element
        let dest = targetIdx;
        if (srcIdx < dest) dest = dest - 1;
        moveInArray(inventory, srcIdx, dest);
        renderInventory();
      } else if (data.startsWith('altar:')){
        const aIdx = Number(data.split(':')[1]);
        if (isNaN(aIdx)) return;
        const cardObj = altarSlots[aIdx];
        if (!cardObj) return;
        altarSlots[aIdx] = null;
        inventory.splice(targetIdx,0,cardObj);
        renderInventory();
      }
    });
  });
}

/* Altar Rendering & Drag from altar */
function renderAltar(){
  const slots = document.querySelectorAll('.altar-slot');
  slots.forEach(slotEl => {
    const idx = Number(slotEl.dataset.index);
    slotEl.innerHTML = '';
    if (altarSlots[idx]){
      const c = altarSlots[idx];
      const d = document.createElement('div');
      d.className = `small-card ${rarityClass(c.rarity)}`;
      d.draggable = true;
      d.dataset.altarIndex = idx;
      d.innerHTML = `<div class="ornament">${c.icon}</div><div class="rarity">${c.rarity}</div><div class="name">${c.name}</div><div class="icon" style="font-size:36px">${c.icon}</div><div class="stars">${'âœ¦'.repeat(c.quality)}</div>`;
      d.addEventListener('dragstart', e => {
        e.dataTransfer.setData('text/plain', 'altar:' + idx);
        try { e.dataTransfer.setDragImage(new Image(), 0, 0); } catch(e){}
        d.classList.add('dragging');
        try{ e.dataTransfer.effectAllowed = 'move'; } catch(e){}
      });
      d.addEventListener('dragend', e => { d.classList.remove('dragging'); });
      slotEl.appendChild(d);
    }
  });
}

/* Altar slots droppable */
const altarSlotElements = document.querySelectorAll('.altar-slot');
altarSlotElements.forEach(slot => {
  slot.addEventListener('dragover', e => {
    e.preventDefault();
    slot.classList.add('over');
  });
  slot.addEventListener('dragleave', e => slot.classList.remove('over'));
  slot.addEventListener('drop', e => {
    e.preventDefault();
    slot.classList.remove('over');
    const data = e.dataTransfer.getData('text/plain');
    const slotIdx = Number(slot.dataset.index);
    if (!data) return;
    if (data.startsWith('inv:')){
      const invIdx = Number(data.split(':')[1]);
      if (isNaN(invIdx) || invIdx < 0 || invIdx >= inventory.length) return;
      const card = inventory.splice(invIdx,1)[0];
      if (altarSlots[slotIdx]){
        // tausche: vorherige Karte zurÃ¼ck ins Inventar (ans Ende)
        inventory.push(altarSlots[slotIdx]);
      }
      altarSlots[slotIdx] = card;
      renderInventory();
    } else if (data.startsWith('altar:')){
      const fromIdx = Number(data.split(':')[1]);
      if (isNaN(fromIdx) || fromIdx < 0 || fromIdx >= altarSlots.length) return;
      if (fromIdx === slotIdx) return;
      const tmp = altarSlots[slotIdx];
      altarSlots[slotIdx] = altarSlots[fromIdx];
      altarSlots[fromIdx] = tmp;
      renderAltar();
    }
  });
});

/* Ziehen vom Altar zurÃ¼ck ins Inventar (auf leeren Inventarbereich = ans Ende) */
const inventoryEl = document.getElementById('inventory');
inventoryEl.addEventListener('dragover', e => e.preventDefault());
inventoryEl.addEventListener('drop', e => {
  e.preventDefault();
  const data = e.dataTransfer.getData('text/plain');
  if (!data) return;
  if (data.startsWith('altar:')){
    const idx = Number(data.split(':')[1]);
    if (isNaN(idx)) return;
    const card = altarSlots[idx];
    if (!card) return;
    altarSlots[idx] = null;
    inventory.push(card);
    renderInventory();
  } else if (data.startsWith('inv:')){
    // wenn auf freien Bereich fallen, ans Ende verschieben
    const src = Number(data.split(':')[1]);
    if (isNaN(src)) return;
    moveInArray(inventory, src, Math.max(0, inventory.length-1));
    renderInventory();
  }
});

const DRAG_SCROLL = { edge: 80, step: 16 };
let scrollFrame = null;
/* Auto-Scroll beim Ziehen: erlaubt Scrollen wÃ¤hrend Karten gehalten werden */
document.addEventListener('dragover', e => {
  if (scrollFrame) return;
  const y = e.clientY;
  // throttled via requestAnimationFrame, damit Scroll nur einmal pro Frame ausgelÃ¶st wird
  scrollFrame = requestAnimationFrame(() => {
    if (y < DRAG_SCROLL.edge){
      window.scrollBy({ top: -DRAG_SCROLL.step, behavior: 'smooth' });
    } else if (window.innerHeight - y < DRAG_SCROLL.edge){
      window.scrollBy({ top: DRAG_SCROLL.step, behavior: 'smooth' });
    }
    scrollFrame = null;
  });
});

/* Opfer- / Belohnungslogik
   Regeln:
   - Wenn alle 3 belegten Slots dieselbe Seltenheit haben -> garantiert nÃ¤chsthÃ¶here Seltenheit (falls vorhanden).
   - Sonstige Logik: highest rarity + Chance auf bump basierend auf QualitÃ¤t.
   - Belohnung bekommt immer eine zufÃ¤llige QualitÃ¤t (randomQuality()).
*/
function summonFromAltar(){
  const filled = altarSlots.filter(s => s !== null);
  if (filled.length === 0){
    document.getElementById('altar-result').textContent = 'Leerer Altar â€” lege Karten hinein.';
    return;
  }

  // counts & quick-check ob alle 3 gleich (und es sind 3 gelegt)
  const counts = {};
  altarSlots.forEach(s => { if (s) counts[s.rarity] = (counts[s.rarity]||0) + 1; });

  if (filled.length === 3){
    const raritiesSet = Object.keys(counts);
    if (raritiesSet.length === 1){
      // alle drei gleich -> garantierter Bump um 1 Tier (wenn mÃ¶glich)
      const currentRarity = raritiesSet[0];
      const idx = Math.max(0, tiers.indexOf(currentRarity));
      const rewardIndex = Math.min(idx + 1, tiers.length - 1);
      const reward = pickRandomCardByRarity(tiers[rewardIndex]);
      reward.quality = randomQuality();
      altarSlots = [null, null, null];
      inventory.push(reward);
      renderInventory();
      document.getElementById('altar-result').innerHTML = `Opfer erfolgreich: 3 Ã— ${currentRarity} â†’ Belohnung: <strong>${reward.name}</strong> ${reward.icon} (${reward.rarity})`;
      return;
    }
  }

  // sonstige Logik wie vorher: highest rarity + chance auf bump basierend auf QualitÃ¤t
  let maxIndex = 0;
  altarSlots.forEach(s => { if (!s) return; const idx = tiers.indexOf(s.rarity); if (idx > maxIndex) maxIndex = idx; });
  const totalQuality = filled.reduce((a,b)=>a+(b?b.quality:0),0);
  let bumpChance = Math.min(0.25 + (totalQuality - filled.length)*0.06, 0.6);
  let rewardIndex = Math.min(maxIndex + (Math.random() < bumpChance ? 1 : 0), tiers.length-1);
  const reward = pickRandomCardByRarity(tiers[rewardIndex]);
  reward.quality = randomQuality();
  altarSlots = [null, null, null];
  inventory.push(reward);
  renderInventory();
  document.getElementById('altar-result').innerHTML = `Belohnung erhalten: <strong>${reward.name}</strong> ${reward.icon} (${reward.rarity})`;
}

/* Hook Buttons */
document.getElementById('drawBtn').addEventListener('click', drawCard);
document.getElementById('sacrificeBtn').addEventListener('click', summonFromAltar);

/* Init - Demo Startkarten */
(function initDemo(){
  for (let i=0;i<4;i++) drawCard();
})();
</script>
</body>
</html>
