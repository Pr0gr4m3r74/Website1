<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-Game — Schach</title>
<link rel="stylesheet" href="chess.css" />
</head>
<body>
<header>
  <h1>Schach</h1>
  <nav>
    <a href="index.html">Start</a>
    <a href="minigames.html" aria-current="page">Mini-Games</a>
    <a href="projects.html">Projekte</a>
    <a href="kontakt.html">Kontakt</a>
    <a href="impressum.html">Impressum</a>
  </nav>
</header>

<main>
  <h2>Spiele gegen einen einfachen Computergegner</h2>
  <div class="board-wrap">
    <div id="board"></div>
    <div class="controls">
      <div class="status" id="status">Status: Bereit</div>
      <div class="advantage">
        <div class="advantage-labels"><span>Weiß</span><span>Schwarz</span></div>
        <div class="advantage-track" aria-label="Vorteilsanzeige">
          <div id="advantageFill" class="advantage-fill"></div>
        </div>
      </div>
      <button id="newGameBtn">Neues Spiel</button>
      <button id="undoBtn">Rückgängig</button>
      <label class="status">Difficulty: Einfach (Heuristik)</label>
      <label class="status">Bauern werden automatisch zur Dame befördert.</label>
      <div class="captured">
        <div><strong>Gefallene weiße Figuren:</strong> <span id="capturedWhite">—</span></div>
        <div><strong>Gefallene schwarze Figuren:</strong> <span id="capturedBlack">—</span></div>
      </div>
      <div class="moves" id="moves">Züge: —</div>
    </div>
  </div>
</main>

<footer>© 2026 IT Solutions</footer>

<script>
const boardEl = document.getElementById('board');
const statusEl = document.getElementById('status');
const movesEl = document.getElementById('moves');
const capturedWhiteEl = document.getElementById('capturedWhite');
const capturedBlackEl = document.getElementById('capturedBlack');
const advantageFillEl = document.getElementById('advantageFill');
const humanColor = 'w';
const aiColor = 'b';
const PIECE_VALUES = { p:1, n:3, b:3, r:5, q:9, k:100 };
const pieceSymbols = {
  'P':'♙','p':'♟','R':'♖','r':'♜','N':'♘','n':'♞','B':'♗','b':'♝','Q':'♕','q':'♛','K':'♔','k':'♚'
};

function evaluateMaterial(board){
  let score = 0;
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const piece = board[r][c];
      if (!piece) continue;
      const val = PIECE_VALUES[piece.toLowerCase()];
      if (!val) continue;
      score += pieceColor(piece) === 'w' ? val : -val;
    }
  }
  return score;
}

function renderCaptured(){
  capturedWhiteEl.textContent = state.captured.w.length ? state.captured.w.map(p => pieceSymbols[p]).join(' ') : '—';
  capturedBlackEl.textContent = state.captured.b.length ? state.captured.b.map(p => pieceSymbols[p]).join(' ') : '—';
}

function updateAdvantageBar(){
  const score = evaluateMaterial(state.board);
  const clamped = Math.max(-12, Math.min(12, score));
  const percent = 50 + (clamped / 12) * 50;
  advantageFillEl.style.width = `${percent}%`;
  advantageFillEl.style.background = score >= 0
    ? 'linear-gradient(90deg,#f8fafc,#38bdf8)'
    : 'linear-gradient(90deg,#0f172a,#0b1224)';
  advantageFillEl.setAttribute('aria-valuenow', percent.toFixed(1));
  advantageFillEl.setAttribute('aria-label', score === 0 ? 'Ausgeglichen' : (score > 0 ? 'Vorteil Weiß' : 'Vorteil Schwarz'));
}

function createInitialBoard(){
  return [
    ['r','n','b','q','k','b','n','r'],
    ['p','p','p','p','p','p','p','p'],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['','','','','','','',''],
    ['P','P','P','P','P','P','P','P'],
    ['R','N','B','Q','K','B','N','R']
  ];
}

function cloneState(state){
  return {
    board: state.board.map(r => r.slice()),
    turn: state.turn,
    castling: { ...state.castling },
    enPassant: state.enPassant ? { r: state.enPassant.r, c: state.enPassant.c } : null,
    halfmove: state.halfmove,
    fullmove: state.fullmove,
    history: state.history ? state.history.slice() : [],
    moves: [...state.moves],
    captured: { w:[...state.captured.w], b:[...state.captured.b] },
    gameOver: state.gameOver,
    winner: state.winner
  };
}

function freshState(){
  return {
    board: createInitialBoard(),
    turn: 'w',
    castling: { wK:true, wQ:true, bK:true, bQ:true },
    enPassant: null,
    halfmove: 0,
    fullmove: 1,
    history: [],
    moves: [],
    captured: { w:[], b:[] },
    gameOver: false,
    winner: null
  };
}

function refreshLegalMoves(){
  if (state.gameOver){
    cachedLegal = [];
    return;
  }
  let moves = legalMoves(state, state.turn);
  cachedLegal = moves;
}

let state = freshState();
let selectedSquare = null;
let highlightedTargets = [];
let cachedLegal = [];

const files = ['a','b','c','d','e','f','g','h'];

function inBounds(r,c){ return r >= 0 && r < 8 && c >= 0 && c < 8; }
function pieceColor(piece){ return piece ? (piece === piece.toUpperCase() ? 'w' : 'b') : null; }
function opponent(color){ return color === 'w' ? 'b' : 'w'; }
function squareName(r,c){ return files[c] + (8 - r); }

function findKing(board,color){
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const piece = board[r][c];
      if (piece && piece.toLowerCase() === 'k' && pieceColor(piece) === color) return {r,c};
    }
  }
  return null;
}

function isSquareAttacked(board, byColor, r, c){
  const pawnDir = byColor === 'w' ? -1 : 1;
  // pawns
  for (const dc of [-1,1]){
    const pr = r + pawnDir;
    const pc = c + dc;
    if (inBounds(pr,pc)){
      const p = board[pr][pc];
      if (p && p.toLowerCase() === 'p' && pieceColor(p) === byColor) return true;
    }
  }
  // knights
  const knightDeltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  for (const [dr,dc] of knightDeltas){
    const nr = r + dr, nc = c + dc;
    if (!inBounds(nr,nc)) continue;
    const p = board[nr][nc];
    if (p && p.toLowerCase() === 'n' && pieceColor(p) === byColor) return true;
  }
  // bishops / queens
  const bishopDirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
  for (const [dr,dc] of bishopDirs){
    let nr = r + dr, nc = c + dc;
    while (inBounds(nr,nc)){
      const p = board[nr][nc];
      if (p){
        const color = pieceColor(p);
        if (color === byColor && (p.toLowerCase() === 'b' || p.toLowerCase() === 'q')) return true;
        break;
      }
      nr += dr; nc += dc;
    }
  }
  // rooks / queens
  const rookDirs = [[1,0],[-1,0],[0,1],[0,-1]];
  for (const [dr,dc] of rookDirs){
    let nr = r + dr, nc = c + dc;
    while (inBounds(nr,nc)){
      const p = board[nr][nc];
      if (p){
        const color = pieceColor(p);
        if (color === byColor && (p.toLowerCase() === 'r' || p.toLowerCase() === 'q')) return true;
        break;
      }
      nr += dr; nc += dc;
    }
  }
  // king
  for (let dr=-1; dr<=1; dr++){
    for (let dc=-1; dc<=1; dc++){
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (!inBounds(nr,nc)) continue;
      const p = board[nr][nc];
      if (p && p.toLowerCase() === 'k' && pieceColor(p) === byColor) return true;
    }
  }
  return false;
}

function isInCheck(state, color){
  const kingPos = findKing(state.board, color);
  if (!kingPos) return false;
  return isSquareAttacked(state.board, opponent(color), kingPos.r, kingPos.c);
}

function generatePseudoMoves(state, color){
  const moves = [];
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const piece = state.board[r][c];
      if (!piece || pieceColor(piece) !== color) continue;
      const lower = piece.toLowerCase();
      if (lower === 'p'){
        generatePawnMoves(state, color, r, c, moves);
      } else if (lower === 'n'){
        generateKnightMoves(state, color, r, c, moves);
      } else if (lower === 'b'){
        generateSlidingMoves(state, color, r, c, moves, [[1,1],[1,-1],[-1,1],[-1,-1]]);
      } else if (lower === 'r'){
        generateSlidingMoves(state, color, r, c, moves, [[1,0],[-1,0],[0,1],[0,-1]]);
      } else if (lower === 'q'){
        generateSlidingMoves(state, color, r, c, moves, [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]);
      } else if (lower === 'k'){
        generateKingMoves(state, color, r, c, moves);
      }
    }
  }
  return moves;
}

function generatePawnMoves(state, color, r, c, moves){
  const dir = color === 'w' ? -1 : 1;
  const startRank = color === 'w' ? 6 : 1;
  const promotionRank = color === 'w' ? 0 : 7;
  const oneStep = {r: r + dir, c};
  if (inBounds(oneStep.r, oneStep.c) && !state.board[oneStep.r][oneStep.c]){
    moves.push({
      from:{r,c},
      to:{...oneStep},
      piece: state.board[r][c],
      promotion: oneStep.r === promotionRank
    });
    const twoStep = {r: r + dir*2, c};
    if (r === startRank && !state.board[twoStep.r][twoStep.c]){
      moves.push({
        from:{r,c},
        to:{...twoStep},
        piece: state.board[r][c],
        doubleStep:true
      });
    }
  }
  for (const dc of [-1,1]){
    const tr = r + dir, tc = c + dc;
    if (!inBounds(tr,tc)) continue;
    const target = state.board[tr][tc];
    if (target && pieceColor(target) === opponent(color)){
      moves.push({
        from:{r,c},
        to:{r:tr,c:tc},
        piece: state.board[r][c],
        captured: target,
        promotion: tr === promotionRank
      });
    } else if (state.enPassant && state.enPassant.r === tr && state.enPassant.c === tc){
      moves.push({
        from:{r,c},
        to:{r:tr,c:tc},
        piece: state.board[r][c],
        captured: color === 'w' ? 'p' : 'P',
        enPassant:true
      });
    }
  }
}

function generateKnightMoves(state, color, r, c, moves){
  const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
  for (const [dr,dc] of deltas){
    const nr = r + dr, nc = c + dc;
    if (!inBounds(nr,nc)) continue;
    const target = state.board[nr][nc];
    if (!target || pieceColor(target) !== color){
      moves.push({
        from:{r,c},
        to:{r:nr,c:nc},
        piece: state.board[r][c],
        captured: target
      });
    }
  }
}

function generateSlidingMoves(state, color, r, c, moves, directions){
  for (const [dr,dc] of directions){
    let nr = r + dr, nc = c + dc;
    while (inBounds(nr,nc)){
      const target = state.board[nr][nc];
      if (!target){
        moves.push({ from:{r,c}, to:{r:nr,c:nc}, piece: state.board[r][c] });
      } else {
        if (pieceColor(target) !== color){
          moves.push({ from:{r,c}, to:{r:nr,c:nc}, piece: state.board[r][c], captured: target });
        }
        break;
      }
      nr += dr; nc += dc;
    }
  }
}

function generateKingMoves(state, color, r, c, moves){
  for (let dr=-1; dr<=1; dr++){
    for (let dc=-1; dc<=1; dc++){
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (!inBounds(nr,nc)) continue;
      const target = state.board[nr][nc];
      if (!target || pieceColor(target) !== color){
        moves.push({ from:{r,c}, to:{r:nr,c:nc}, piece: state.board[r][c], captured: target });
      }
    }
  }
  // castling
  if (color === 'w' && r === 7 && c === 4){
    if (state.castling.wK && state.board[7][7] === 'R' && !state.board[7][5] && !state.board[7][6]){
      if (!isSquareAttacked(state.board, 'b', 7,4) && !isSquareAttacked(state.board, 'b', 7,5) && !isSquareAttacked(state.board, 'b', 7,6)){
        moves.push({ from:{r,c}, to:{r:7,c:6}, piece: state.board[r][c], castle:'K' });
      }
    }
    if (state.castling.wQ && state.board[7][0] === 'R' && !state.board[7][1] && !state.board[7][2] && !state.board[7][3]){
      if (!isSquareAttacked(state.board, 'b', 7,4) && !isSquareAttacked(state.board, 'b', 7,3) && !isSquareAttacked(state.board, 'b', 7,2)){
        moves.push({ from:{r,c}, to:{r:7,c:2}, piece: state.board[r][c], castle:'Q' });
      }
    }
  }
  if (color === 'b' && r === 0 && c === 4){
    if (state.castling.bK && state.board[0][7] === 'r' && !state.board[0][5] && !state.board[0][6]){
      if (!isSquareAttacked(state.board, 'w', 0,4) && !isSquareAttacked(state.board, 'w', 0,5) && !isSquareAttacked(state.board, 'w', 0,6)){
        moves.push({ from:{r,c}, to:{r:0,c:6}, piece: state.board[r][c], castle:'K' });
      }
    }
    if (state.castling.bQ && state.board[0][0] === 'r' && !state.board[0][1] && !state.board[0][2] && !state.board[0][3]){
      if (!isSquareAttacked(state.board, 'w', 0,4) && !isSquareAttacked(state.board, 'w', 0,3) && !isSquareAttacked(state.board, 'w', 0,2)){
        moves.push({ from:{r,c}, to:{r:0,c:2}, piece: state.board[r][c], castle:'Q' });
      }
    }
  }
}

function legalMoves(state, color){
  const pseudo = generatePseudoMoves(state, color);
  const legal = [];
  for (const move of pseudo){
    const sim = cloneState(state);
    sim.turn = color;
    executeMove(sim, move, { recordHistory: false, addNotation: false });
    if (!isInCheck(sim, color)){
      legal.push(move);
    }
  }
  return legal;
}

function executeMove(currentState, move, { recordHistory = true, addNotation = true } = {}){
  const color = currentState.turn;
  const opp = opponent(color);
  const piece = move.piece || currentState.board[move.from.r][move.from.c];
  const targetPiece = move.castle ? null : currentState.board[move.to.r][move.to.c];
  const capturedPiece = move.enPassant ? (color === 'w' ? 'p' : 'P') : targetPiece;
  const isPawn = piece.toLowerCase() === 'p';
  const isCapture = !!capturedPiece;

  if (recordHistory){
    currentState.history.push(cloneState(currentState));
  }

  currentState.enPassant = null;

  if (move.castle){
    if (color === 'w'){
      const kingTargetCol = move.castle === 'K' ? 6 : 2;
      currentState.board[7][4] = '';
      currentState.board[7][kingTargetCol] = 'K';
      if (move.castle === 'K'){
        currentState.board[7][7] = '';
        currentState.board[7][5] = 'R';
      } else {
        currentState.board[7][0] = '';
        currentState.board[7][3] = 'R';
      }
    } else {
      const kingTargetCol = move.castle === 'K' ? 6 : 2;
      currentState.board[0][4] = '';
      currentState.board[0][kingTargetCol] = 'k';
      if (move.castle === 'K'){
        currentState.board[0][7] = '';
        currentState.board[0][5] = 'r';
      } else {
        currentState.board[0][0] = '';
        currentState.board[0][3] = 'r';
      }
    }
  } else {
    currentState.board[move.from.r][move.from.c] = '';
    const promoteTo = move.promotion ? (color === 'w' ? 'Q' : 'q') : piece;
    currentState.board[move.to.r][move.to.c] = promoteTo;
    if (move.enPassant){
      const capRow = move.to.r + (color === 'w' ? 1 : -1);
      currentState.board[capRow][move.to.c] = '';
    }
  }

  if (capturedPiece){
    const capColor = pieceColor(capturedPiece);
    if (capColor){
      currentState.captured[capColor].push(capturedPiece);
    }
    if (capturedPiece.toLowerCase() === 'k'){
      currentState.gameOver = true;
      currentState.winner = color;
    }
  }

  // castling rights update
  if (piece.toLowerCase() === 'k'){
    if (color === 'w'){ currentState.castling.wK = false; currentState.castling.wQ = false; }
    else { currentState.castling.bK = false; currentState.castling.bQ = false; }
  }
  if (piece.toLowerCase() === 'r'){
    if (color === 'w'){
      if (move.from.r === 7 && move.from.c === 0) currentState.castling.wQ = false;
      if (move.from.r === 7 && move.from.c === 7) currentState.castling.wK = false;
    } else {
      if (move.from.r === 0 && move.from.c === 0) currentState.castling.bQ = false;
      if (move.from.r === 0 && move.from.c === 7) currentState.castling.bK = false;
    }
  }
  if (targetPiece && targetPiece.toLowerCase() === 'r'){
    const targetColor = pieceColor(targetPiece);
    if (targetColor === 'w'){
      if (move.to.r === 7 && move.to.c === 0) currentState.castling.wQ = false;
      if (move.to.r === 7 && move.to.c === 7) currentState.castling.wK = false;
    } else {
      if (move.to.r === 0 && move.to.c === 0) currentState.castling.bQ = false;
      if (move.to.r === 0 && move.to.c === 7) currentState.castling.bK = false;
    }
  }

  if (isPawn && Math.abs(move.from.r - move.to.r) === 2){
    currentState.enPassant = { r: move.from.r + (color === 'w' ? -1 : 1), c: move.to.c };
  }

  currentState.halfmove = (isPawn || isCapture) ? 0 : currentState.halfmove + 1;
  if (color === 'b') currentState.fullmove += 1;

  if (!currentState.gameOver && !findKing(currentState.board, opp)){
    currentState.gameOver = true;
    currentState.winner = color;
  }

  if (addNotation){
    const checkAfter = !currentState.gameOver && isInCheck(currentState, opp);
    const mateAfter = checkAfter && legalMoves(currentState, opp).length === 0;
    currentState.moves.push(buildNotation(move, piece, isCapture, color, checkAfter, mateAfter));
  }

  currentState.turn = opp;
}

function buildNotation(move, piece, isCapture, color, checkAfter, mateAfter){
  if (move.castle) return (color === 'w' ? 'Weiß: ' : 'Schwarz: ') + (move.castle === 'K' ? 'O-O' : 'O-O-O');
  const colorLabel = color === 'w' ? 'Weiß' : 'Schwarz';
  const pieceLetter = piece.toLowerCase() === 'p' ? '' : piece.toUpperCase();
  const from = squareName(move.from.r, move.from.c);
  const to = squareName(move.to.r, move.to.c);
  const promo = move.promotion ? '=Q' : '';
  const suffix = mateAfter ? '#' : (checkAfter ? '+' : '');
  return `${colorLabel}: ${pieceLetter}${from}${isCapture ? 'x' : '–'}${to}${promo}${suffix}`;
}

function renderBoard(){
  boardEl.innerHTML = '';
  for (let r=0; r<8; r++){
    for (let c=0; c<8; c++){
      const btn = document.createElement('button');
      btn.className = `square ${((r+c)%2===0) ? 'dark' : 'light'}`;
      if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c){
        btn.classList.add('selected');
      }
      if (highlightedTargets.some(t => t.r === r && t.c === c)){
        btn.classList.add('option');
      }
      btn.setAttribute('data-square', squareName(r,c));
      btn.setAttribute('aria-label', `Feld ${squareName(r,c)}`);
      const piece = state.board[r][c];
      btn.textContent = piece ? pieceSymbols[piece] : '';
      btn.addEventListener('click', ()=>handleSquareClick(r,c));
      boardEl.appendChild(btn);
    }
  }
  boardEl.classList.add('chessboard');
}

function handleSquareClick(r,c){
  if (state.gameOver) return;
  if (cachedLegal.length === 0) return;
  const piece = state.board[r][c];
  if (selectedSquare){
    const move = highlightedTargets.find(t => t.r === r && t.c === c);
    if (move){
      makePlayerMove(move.original);
      return;
    }
  }
  if (piece && pieceColor(piece) === state.turn && state.turn === humanColor){
    selectedSquare = {r,c};
    const options = cachedLegal.filter(m => m.from.r === r && m.from.c === c);
    highlightedTargets = options.map(m => ({ r:m.to.r, c:m.to.c, original:m }));
  } else {
    selectedSquare = null;
    highlightedTargets = [];
  }
  renderBoard();
}

function makePlayerMove(move){
  if (state.gameOver) return;
  executeMove(state, move);
  refreshLegalMoves();
  selectedSquare = null;
  highlightedTargets = [];
  renderBoard();
  updateStatus();
  if (!state.gameOver && state.turn === aiColor && cachedLegal.length > 0){
    setTimeout(makeAIMove, 300);
  }
}

function chooseAIMove(moves){
  let best = [];
  let bestScore = -Infinity;
  for (const move of moves){
    const sim = cloneState(state);
    executeMove(sim, move, { recordHistory:false });
    const opp = opponent(aiColor);
    const deliversCheck = isInCheck(sim, opp);
    const deliversMate = deliversCheck ? legalMoves(sim, opp).length === 0 : false;
    const captured = move.captured ? move.captured.toLowerCase() : null;
    const capturedValue = captured ? (PIECE_VALUES[captured] ?? 0) : 0;
    let score = capturedValue;
    if (deliversMate) score += 1000;
    else if (deliversCheck) score += 50;
    if (score > bestScore){
      bestScore = score;
      best = [move];
    } else if (score === bestScore){
      best.push(move);
    }
  }
  return best[Math.floor(Math.random() * best.length)];
}

function makeAIMove(){
  if (state.gameOver || state.turn !== aiColor) return;
  const moves = cachedLegal;
  if (!moves.length){
    updateStatus();
    return;
  }
  const move = chooseAIMove(moves);
  executeMove(state, move);
  refreshLegalMoves();
  renderBoard();
  updateStatus();
}

function updateStatus(){
  const legal = cachedLegal;
  const inCheck = !state.gameOver && isInCheck(state, state.turn);
  let message = '';
  if (state.gameOver){
    const winnerText = state.winner ? (state.winner === 'w' ? 'Weiß' : 'Schwarz') : 'Niemand';
    message = state.winner ? `${winnerText} hat gewonnen (König gefallen).` : 'Spiel beendet.';
  } else if (!legal.length){
    message = inCheck ? `Schachmatt — ${(state.turn === 'w' ? 'Schwarz' : 'Weiß')} hat gewonnen.` : 'Patt — Unentschieden.';
  } else {
    message = `Am Zug: ${state.turn === 'w' ? 'Weiß' : 'Schwarz'}${inCheck ? ' (Schach!)' : ''}`;
  }
  statusEl.textContent = 'Status: ' + message;
  movesEl.innerHTML = state.moves.length ? `<strong>Alle Züge</strong><br>${state.moves.join('<br>')}` : 'Züge: —';
  renderCaptured();
  updateAdvantageBar();
}

function resetGame(){
  state = freshState();
  refreshLegalMoves();
  selectedSquare = null;
  highlightedTargets = [];
  renderBoard();
  updateStatus();
}

function undoMoves(times = 1){
  let movesUndone = 0;
  while (movesUndone < times && state.history.length){
    const previous = state.history.pop();
    state = previous;
    movesUndone++;
  }
  refreshLegalMoves();
  selectedSquare = null;
  highlightedTargets = [];
  renderBoard();
  updateStatus();
}

document.getElementById('newGameBtn').addEventListener('click', resetGame);
document.getElementById('undoBtn').addEventListener('click', ()=>{ undoMoves(2); });

refreshLegalMoves();
renderBoard();
updateStatus();
</script>
</body>
</html>
